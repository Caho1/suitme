# Suitme 数字模特图像生成后端技术文档

> 目标读者：Python 后端开发、架构/产品同事 技术栈：FastAPI + MySQL + Apimart Images API

## 目录

1. 系统概述
2. 整体架构与调用链路
3. 核心业务模块
   1. 3.1 默认模特生成（F1）
   2. 3.2 默认模特编辑（F2）
   3. 3.3 穿搭生成（F3）
4. 异步任务机制与状态管理
5. 数据库设计（Python 服务侧）
6. 错误处理与重试策略
7. 与 Java 后端的集成方式
8. 接口设计建议（FastAPI 视角）

## 系统概述

Suitme 的 Python 生图服务负责 **数字模特形象相关的 AI 生成**，包含三个功能点：

1. **生成默认模特** 输入：用户正面照片 + 一些参数（性别、身高、肤色等） 输出：统一风格的“数字模特形象”（默认正面，全身），作为后续穿搭的基底。
2. **编辑默认模特（局部修改）** 输入：已有默认模特形象 + 编辑指令（发型、身材微调等） 输出：在同一人设基础上的新模特图。
3. **穿搭生成** 输入：默认模特形象 + 单品服装图（正面必填，侧/背选填） 输出：模特穿上对应单品的穿搭图，支持 front / side / back 视角。

本服务只面向 **Java 后端**，不直接对前端暴露。 使用 **Apimart 图像生成** **API**（异步任务模式：`POST v1/images/generations` + `GET v1/tasks/{task_id}`）进行实际的生图。

*后文如无特殊说明，Apimart 路径都默认带 `/v1` 前缀

## 整体架构与调用链路

### 2.1 组件关系

```Plain
flowchart LR
    FE[前端导购端] -->|HTTP JSON| JAVA[Java 业务后端]

    JAVA -->|HTTP JSON\n(内部调用)| PY[Python 生图服务]

    PY -->|HTTP JSON\n提交任务 & 轮询状态| APIMART[Apimart Images API]

    PY -->|SQL| DB[(MySQL)]

    PY -->|HTTP JSON\n回传结果| JAVA
    JAVA --> FE
```

![img](https://ycnowv5llmsk.feishu.cn/space/api/box/stream/download/asynccode/?code=OTU3YTAyNWE3MGQxOTczY2U0ZGNhNzZhMDVkMWU5NmZfOGt5MUw0VTZ4VFBCdWNCdmduRVU5eWNHNnhLbWIzd0dfVG9rZW46S0pUSmJXdktLb2Jwajh4YzF5cGNBZm13bmJDXzE3NjQ5NTIzMDE6MTc2NDk1NTkwMV9WNA)

### 2.2 高层流程（文本时序）

以“生成默认模特”为例：

1. 前端填写用户参数 + 上传正面照片 → Java。
2. Java 上传照片到 OSS（或直接转 Base64），整理参数 → 调用 Python： 
   1. `POST /models/default`。
3. Python 校验参数 → 调用 Apimart `POST /v1/images/generations`，获取 `task_id`。
4. Python 把任务写入 `tasks` 表（状态 `submitted`），并返回 202 + 本地 `task_id` 给 Java。
5. Python 后台定时（或立即异步）轮询 `GET /v1/tasks/{task_id}`，直到： 
   1. `completed` → 获取图片 URL → 下载 → 存 Base64 或上传 OSS → 写 `images` 表 → 更新任务状态为 `completed`。
   2. `failed` / 超时 → 更新任务状态为 `failed`。
6. Python 调用 Java 的回调接口，传回最终结果（任务状态 + 图片 Base64 / OSS URL）。
7. Java 更新自己的业务记录，通知前端刷新页面显示新模特图。

> 说明：
>
> - 对 Java 而言，**Python 是异步的“任务服务”**：创建任务 + 查询任务状态/等待回调。
> - Apimart 的异步细节、轮询逻辑，全都封装在 Python 内部。

## 核心业务模块

下面对 3 个生图功能点逐一描述：**功能说明 → 请求/响应 → 处理流程 → 特殊逻辑**。

### 默认模特生成（F1）

#### 3.1.1 功能说明

“默认模特”是用户在系统中的标准数字形象，用于后续所有穿搭的基底。

- 输入： 
  - 用户正面照片（Base64）
  - 用户参数（性别、身高、体重、年龄、肤色、身材类型等）
- 输出： 
  - 一张风格统一的数字模特全身图（默认 front 正面）

视觉要求（会写入 Prompt）：

- 浅灰简洁背景；
- 正面全身，中远景，完整身体（包含腿和脚）；
- 身高视觉约 180cm，标准模特比例；
- 穿统一“基础服饰”（如灰色背心 + 短裤，具体根据产品定义）；
- 面部特征与用户照片高度一致。

#### 3.1.2 请求接口（FastAPI 视角）

```HTTP
POST /models/default
Content-Type: application/json
```

请求 JSON：

```JSON
{
  "request_id": "uuid-from-java",
  "user_id": "U123",
  "user_image_base64": "data:image/jpeg;base64,...",

  "body_profile": {
    "gender": "male",
    "height_cm": 175,
    "weight_kg": 65,
    "age": 28,
    "skin_tone": "natural_white",
    "body_shape": "rectangle"
  }
}
```

返回（同步创建任务，**不等待结果**）：

```JSON
{
  "code": 0,
  "msg": "accepted",
  "data": {
    "task_id": "py-task-00001",         // Python 内部任务ID
    "status": "submitted"               // 统一状态枚举：submitted/processing/completed/failed
  }
}
```

HTTP 状态码：`202 Accepted`（创建了后台任务）。

#### 3.1.3 处理流程

1. **参数校验**
   1. `user_image_base64` 是否为可解析的 Data URI；
   2. `body_profile` 各字段是否在合理范围；
   3. 校验失败 → 返回 `400 Bad Request`，`code=1001`。
2. **构建 Prompt**
   1. 从配置/模板取出 base_model 的 prompt 模板；
   2. 注入 `gender/height/skin_tone` 等信息；
   3. 强调： 
      - `front full-body view`
      - `simple light gray background`
      - `same face identity`。
3. **调用 Apimart：提交任务**
   1. `POST https://api.apimart.ai/v1/images/generations`
   2. 关键参数： 
      - `model`: 如 `"gemini-3-pro-image-preview"`
      - `prompt`: 上一步构造的完整文本
      - `size`: `"4:3"`（横向 4:3）
      - `n`: `1`
      - `image_urls`: `[{"url": user_image_base64}]`
   3. 成功 → 返回 Apimart `task_id`（外部任务 ID）。
4. **写入本地任务表**
   1. 新增一条 `tasks` 记录： 
      - type = `default`
      - external_task_id = Apimart 的 task_id
      - status = `submitted`
      - progress = 0
      - user_id、body_profile 快照 等。
5. **响应给 Java**
   1. 返回 Python 内部 `task_id`（可以是自增ID或 uuid）。
   2. Java 使用该 ID 进行后续轮询/回调关联。
6. **后台****轮询** **Apimart**
   1. 见 第四章：异步任务机制。

#### 3.1.4 特殊注意点

- 默认只生成 `front` 角度；
- 生成结果不直接给前端 Apimart URL，一定要： 
  - 下载图片 → 存 Base64 或上传 OSS → 再传给 Java；
- Prompt 尽量固定模板 + 参数插值，方便后期调优。

### 默认模特编辑（F2）

#### 3.2.1 功能说明

在已有“默认模特”基础上，允许导购或用户调整部分特征（例如发型、身材微调、肤色略深等），生成新的数字形象，但需保持人物身份一致。

- 输入： 
  - 已有默认模特图（通过 `base_model_task_id` 或 Base64）
  - 编辑指令（自然语言或结构化参数）
- 输出： 
  - 新的默认模特图（仍为 front，风格统一）

#### 3.2.2 请求接口

```HTTP
POST /models/edit
Content-Type: application/json
```

请求 JSON 示例：

```JSON
{
  "request_id": "uuid-from-java",
  "user_id": "U123",
  "base_model_task_id": "py-task-00001",
  "edit_instructions": "身材略瘦一点，发型改为短卷发"
}
```

返回：

```JSON
{
  "code": 0,
  "msg": "accepted",
  "data": {
    "task_id": "py-task-00002",
    "status": "submitted"
  }
}
```

#### 3.2.3 处理流程

1. **获取基础模特图**
   1. 通过 `base_model_task_id` 查询图片表；
   2. 获取该任务的最终图片（Base64 或 OSS URL 并下载）；
   3. 无图 → 返回 `400` 或 `404`（基础形象不存在）。
2. **构建编辑 Prompt**
   1. 模板示例： 
   2. - Based on the provided model photo, make the following adjustments: {edit_instructions}. Keep the same face identity, same overall style, and same background.
   3. 将基础模特图作为 `image_urls` 传入（以图生图）。
3. **调用 Apimart（以图编辑）**
   1. 仍然使用 `/images/generations`；
   2. `image_urls` 包含基础模特图；
   3. 如果后续有 mask 方案，可额外传 mask 限制编辑范围。
4. **任务记录**
   1. type = `edit`；
   2. 关联 `base_model_task_id`；
   3. 其他与 F1 一致。
5. **轮询 & 落库 & 回调**
   1. 与 F1 相同，只是类型为 `edit`。

### 穿搭生成（F3）

#### 3.3.1 功能说明

将服装单品图“穿”到默认模特形象上，生成穿搭效果图：

- 默认必须生成 **front** 视角；
- 若上传了背面/侧面服装图，则可以额外生成 `back` / `side` 视角；
- 前端最终按角度展示不同视图。

#### 3.3.2 接口设计（建议单视角调用）

```HTTP
POST /models/outfit
Content-Type: application/json
```

请求 JSON 示例（生成正面穿搭）：

```JSON
{
  "request_id": "uuid-from-java",
  "user_id": "U123",

  "base_model_task_id": "py-task-00001",      // 默认模特任务ID
  "angle": "front",                           // front / side / back

  "outfit_image_base64": "data:image/jpeg;base64,...",   // 对应视角的服装图
  "outfit_description": "蓝色休闲衬衫，棉麻材质，宽松版型"
}
```

返回：

```JSON
{
  "code": 0,
  "msg": "accepted",
  "data": {
    "task_id": "py-task-00003",
    "status": "submitted",
    "angle": "front"
  }
}
```

> 说明：
>
> - 如需生成 side/back，可多次调用该接口（只改变 angle 和服装图）。
> - 若你更想“一次请求生成多角度”，可以设计一个批量接口 `/models/outfit/batch`，内部拆成多个子任务；当前文档以单视角为主，接口简单清晰。

#### 3.3.3 处理流程

1. **校验 angle & 服装图**
   1. `angle` 必须在 `front/back/side` 枚举中；
   2. 若 angle 不是 `front`，但没有对应角度服装图（调用方约定），建议 Java 在上游就拦截；
   3. Python 若收到 `angle=side` 但服装图明显是正面，可以选择： 
      - 直接继续（可能效果差），或者
      - 记日志并标记“角度可能不匹配”。
2. **获取基础模特图**
   1. 同编辑模块，通过 `base_model_task_id` 查出基础模特图。
3. **构建穿搭 Prompt（包含角度标注）**
4. 示例：

> 1. Based on the given model photo and outfit photo, generate a **front full-body view** of the model wearing this outfit. The model should keep the same face identity, similar body shape and pose. Use a clean light gray background, suitable for fashion e-commerce. Outfit description: {outfit_description}.

1. 对于不同角度：
   1. front → `front full-body view`
   2. side → `side view of the full body`
   3. back → `back view of the full body`
2. **调用 Apimart**
   1. `v1/images/generations`；
   2. `image_urls` 传入： 
      - 基础模特图
      - 服装图
   3. 让模型基于两张图融合生成新图像。
3. **任务记录**
   1. type = `outfit`
   2. angle = 请求的 angle
   3. 其他同前。
4. **轮询 & 落库 & 回调**
   1. 与 F1/F2 一致，只是 angle 不同。

#### 3.3.4 特殊情况

- 单品只有正面图： 
  - 只能可靠生成 `front`，side/back 建议直接报错 or 不开放；
- 多件单品搭配： 
  - 请求体可扩展多件单品字段（数组），在 prompt 中组合多件 `outfit_description`，但当前文档先按“单件单品”设计。

## 异步任务机制与状态管理

Python 服务内部要统一管理所有调用 Apimart 的异步任务：

### 4.1 状态模型

任务状态枚举建议：

- `submitted`：已成功提交到 Apimart，等待处理；
- `processing`：查询到 Apimart 状态为处理中；
- `completed`：生成成功；
- `failed`：生成失败（含超时）；

`tasks` 表中的典型字段：

- `task_id`（Python 内部ID）
- `external_task_id`（Apimart 的 task_id）
- `type`：default / edit / outfit
- `status`：如上枚举
- `progress`：0-100（如有）
- `angle`：front / side / back（仅 outfit 用）
- `error_message`：失败原因

### 4.2 轮询策略

伪逻辑：

```Python
async def poll_apimart_task(task: TaskRecord):
    start = time.monotonic()
    while True:
        if time.monotonic() - start > TASK_TIMEOUT:
            mark_failed(task, "timeout")
            break

        data = await apimart.get_task_status(task.external_task_id)
        status = data["status"]            # submitted / processing / completed / failed
        progress = data.get("progress")

        update_task_progress(task, status, progress)

        if status == "completed":
            await handle_task_completed(task, data)
            break
        elif status == "failed":
            mark_failed(task, data.get("error"))
            break
        else:
            await asyncio.sleep(POLL_INTERVAL)
```

> 注意：
>
> - 可以通过后台定时任务扫描“submitted/processing”的记录，批量轮询。
> - 每个任务轮询间隔例如 2-3 秒，超时时间例如 60-120 秒，配置化。

### 4.3 完成与失败处理

- **完成：**
  - 从返回的 `result.images[0].url[0]` 获取图片 URL；
  - 下载图片 → 转 Base64 或上传 OSS → 写入 `images` 表；
  - 更新 `tasks.status = completed, progress=100, completed_at=...`；
  - 触发结果回调给 Java。
- **失败 / 超时：**
  - 更新 `tasks.status = failed`，记录 `error_message`；
  - 回调 Java，告知失败（由 Java 决定是否给用户重试按钮）。

## 数据库设计（Python 服务侧）

### 5.1 表一：任务表 `ai_generation_task`

**用途：** 记录每一次生图任务（default/edit/outfit）。

| 字段名             | 类型      | 说明                                  |
| ------------------ | --------- | ------------------------------------- |
| id                 | BIGINT PK | 本地任务 ID                           |
| request_id         | VARCHAR   | 上游 Java 传入的 request_id           |
| external_task_id   | VARCHAR   | Apimart 的 task_id                    |
| type               | ENUM      | default / edit / outfit               |
| user_id            | VARCHAR   | 用户 ID（外部）                       |
| base_model_task_id | BIGINT    | 对于 edit/outfit，指向基础模特任务    |
| angle              | VARCHAR   | 仅 outfit 任务有：front/side/back     |
| status             | ENUM      | submitted/processing/completed/failed |
| progress           | INT       | 0-100                                 |
| error_message      | VARCHAR   | 失败原因简述                          |
| created_at         | DATETIME  | 创建时间                              |
| updated_at         | DATETIME  | 更新时间                              |
| completed_at       | DATETIME  | 完成时间                              |

```SQL
CREATE TABLE `ai_generation_task` (
  `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '本地任务 ID',
  `request_id` VARCHAR(64) NOT NULL COMMENT '上游 Java 传入的 request_id',
  `external_task_id` VARCHAR(64) DEFAULT NULL COMMENT 'Apimart 的 task_id',
  `type` ENUM('default', 'edit', 'outfit') NOT NULL COMMENT '任务类型：default / edit / outfit',
  `user_id` VARCHAR(64) NOT NULL COMMENT '用户 ID（外部）',
  `base_model_task_id` BIGINT DEFAULT NULL COMMENT '对 edit/outfit，指向基础模特任务',
  `angle` VARCHAR(32) DEFAULT NULL COMMENT '仅 outfit 任务有：front/side/back',
  `status` ENUM('submitted', 'processing', 'completed', 'failed') NOT NULL COMMENT '任务状态',
  `progress` INT NOT NULL DEFAULT 0 COMMENT '任务进度 0-100',
  `error_message` VARCHAR(512) DEFAULT NULL COMMENT '失败原因描述',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `completed_at` DATETIME DEFAULT NULL COMMENT '完成时间',

  PRIMARY KEY (`id`),

  KEY `idx_request_id` (`request_id`),
  KEY `idx_external_task_id` (`external_task_id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_status_type` (`status`, `type`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='记录每一次生图任务（default/edit/outfit）';
```

### 5.2 表二：图片表 `ai_generation_image`

**用途：** 保存生成的图片信息。

| 字段名       | 类型      | 说明                                                       |
| ------------ | --------- | ---------------------------------------------------------- |
| id           | BIGINT PK | 图片记录 ID                                                |
| task_id      | BIGINT FK | 关联 [ai_generation_task.id](http://ai_generation_task.id) |
| angle        | VARCHAR   | 冗余 angle                                                 |
| image_base64 | LONGTEXT  | 图片 Base64（如存 Base64 时使用）                          |
| image_url    | VARCHAR   | 图片 OSS URL（如上传 OSS 时使用）                          |
| created_at   | DATETIME  | 创建时间                                                   |

```SQL
CREATE TABLE `ai_generation_image` (
  `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '图片记录 ID',
  `task_id` BIGINT NOT NULL COMMENT '关联 ai_generation_task.id',
  `angle` VARCHAR(32) DEFAULT NULL COMMENT '同 angle：front/side/back',
  `image_base64` LONGTEXT DEFAULT NULL COMMENT '图片 Base64（如存 Base64 时使用）',
  `image_url` VARCHAR(512) DEFAULT NULL COMMENT '图片 OSS URL（如上传 OSS 时使用）',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',

  PRIMARY KEY (`id`),

  KEY `idx_task_id` (`task_id`),
  KEY `idx_task_angle` (`task_id`, `angle`),

  CONSTRAINT `fk_image_task`
    FOREIGN KEY (`task_id`) REFERENCES `ai_generation_task` (`id`)
    ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='保存生成的图片信息';
```

## 错误处理与重试策略

### 6.1 Python 对外（给 Java）的错误码

统一返回 JSON 格式：

```JSON
{
  "code": 0,
  "msg": "success 或错误信息",
  "data": { ... 可选 ... }
}
```

建议约定：

| code | 含义                         |
| ---- | ---------------------------- |
| 0    | 成功（或已接受任务）         |
| 1001 | 参数错误（缺字段、格式错误） |
| 1002 | 上游 Apimart 调用失败        |
| 1003 | 任务不存在 / 已过期          |
| 1004 | 内部异常（未分类的错误）     |

同时结合 HTTP 状态码：

- 200：查询任务状态成功；
- 202：任务创建成功，已受理；
- 400：请求参数错误；
- 404：任务未找到；
- 500 / 502：服务内部或上游异常。

### 6.2 Apimart 错误处理

典型情况：

- 400 / 参数错误 → 记录日志，直接标记任务 `failed`，`code=1002`；
- 401 / 鉴权错误 → 配置问题，报警；任务 `failed`；
- 402 / 余额不足 → 任务失败，同时报警；
- 429 / 频率限制 → 可以短时间重试（几次），仍失败则任务失败；
- 5xx → 按重试策略（指数退避）尝试几次，仍失败则任务失败。

### 6.3 任务超时

- 单个 Apimart 任务超过 `TASK_TIMEOUT`（如 120 秒）仍未完成： 
  - 标记任务 `failed`，`error_message = "timeout"`；
  - 回调 Java 告知超时失败。

## 与 Java 后端的集成方式

### 7.1 调用模式

- Java → Python： 
  - `POST /models/default` / `edit` / `outfit` 创建任务；
  - （可选）`GET /tasks/{task_id}` 查询任务当前状态；
- Python → Java： 
  - 回调 URL（如 `/internal/ai/result`），包含： 
    - `task_id`
    - `status`
    - `image_base64` or `image_url`
    - `type` / `angle` 等元信息。

### 7.2 幂等性建议

- 创建任务接口（POST）：**非幂等**
  - 同一 `request_id` 重复调用，可能创建多个任务；
  - 如果你期望幂等，可以在 Python 层根据 `request_id` 做“已存在则复用”逻辑（可选）。
- 查询任务接口（GET）：**幂等**
  - 多次调用 `GET v1/tasks/{task_id}` 不改变状态，只返回当前状态。
- Java 回调接口：建议幂等
  - Python 重试回调时，Java 能识别同一 task_id 的重复消息，不重复写业务数据。

### 7.3 安全性

- Python 服务只在内网暴露；
- Java 调用 Python 可以带一个简单的共享 token（header），Python 校验即可；
- Python 回调 Java 接口同理。

## 接口设计建议（FastAPI 视角）

最后给你一个推荐的 FastAPI 路由结构（伪代码），方便你开工：

```Python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

app = FastAPI()

class BodyProfile(BaseModel):
    gender: str
    height_cm: float
    weight_kg: float
    age: int
    skin_tone: str
    body_shape: str | None = None

class DefaultModelRequest(BaseModel):
    request_id: str
    user_id: str
    user_image_base64: str
    body_profile: BodyProfile

class EditModelRequest(BaseModel):
    request_id: str
    user_id: str
    base_model_task_id: str
    edit_instructions: str

class OutfitModelRequest(BaseModel):
    request_id: str
    user_id: str
    base_model_task_id: str
    angle: str  # front/side/back
    outfit_image_base64: str
    outfit_description: str | None = None

@app.post("/models/default")
async def create_default_model(req: DefaultModelRequest):
    # 1. 校验 & 写 task
    # 2. 调 Apimart 提交任务
    # 3. 返回 task_id
    ...

@app.post("/models/edit")
async def edit_model(req: EditModelRequest):
    ...

@app.post("/models/outfit")
async def create_outfit(req: OutfitModelRequest):
    ...

@app.get("/tasks/{task_id}")
async def get_task_status(task_id: str):
    # 查询 ai_generation_task / ai_generation_image
    # 返回当前状态和（如已完成）图片的 base64/url
    ...
```